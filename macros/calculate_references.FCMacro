# -*- coding: utf-8 -*-
from FreeCAD import Base
Vec = Base.Vector

import numpy as np
import math

design_params = App.ActiveDocument.getObjectsByLabel('design_params')[0]
upcycled_fork = App.ActiveDocument.getObjectsByLabel('upcycled_fork')[0]
ref = App.ActiveDocument.getObjectsByLabel('References')[0]

#aliases = {}
#row = 1
#row_empty = False
#while not row_empty:
#    name = None
#    try:
#        name = ref.get('A{}'.format(row))
#    except ValueError:
#        row_empty = True
#    else:
#        if name:
#            aliases[name] = '{}'.format(row)
#        else:
#            row_empty = True
#    row += 1

current_row = 1
def setref(alias, value, units=None):
    """
    Set a value for the given alias in the References spreadsheet
    """
    global current_row
    formatted_value = value
    if units:
        formatted_value = '{:.2f} {}'.format(value, units)

    ref.set(
        'A{}'.format(current_row),
        alias
    )
    ref.set(
        'B{}'.format(current_row),
        formatted_value
    )
    ref.set(
        'C{}'.format(current_row),
        'FROM PYTHON'
    )
    current_row += 1

def copy_vector(vec):
    """
    Vectors cannot be copied using the python copy module,
    and don't otherwise have a built-in copy mechanism!  So
    this function should suffice.
    """
    return Vec(vec.x, vec.y, vec.z)

def rotation_matrix(axis, theta):
    """
    Return the rotation matrix associated with counterclockwise rotation about
    the given axis by theta radians.
    """
    axis = np.asarray(axis)
    axis = axis/math.sqrt(np.dot(axis, axis))
    a = math.cos(theta/2.0)
    b, c, d = -axis*math.sin(theta/2.0)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    return np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],
                     [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],
                     [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])

def rotated_about_axis(vector, axis, theta):
    """
    Rotate the given Vector according to the given axis and theta.

    Returns:
        a new vector
    """
    rotated = np.dot(rotation_matrix(axis, theta), np.asarray(vector))
    return Vec(rotated)

def line_line_intersection(l1, l2):
    """
    Assume the lines intersect in 3D, and do a 2D intersection by selecting the
    two best dimensions out of the three.  Plug the solution back into l1 to
    get the final intersection point in 3D.

    FIXME: UNTESTED
    """
    # point p is perpendicular to both lines
    p = l1[1].cross(l2[1])
    p0 = math.fabs(p[0])
    p1 = math.fabs(p[1])
    p2 = math.fabs(p[2])
    axisA = 0
    axisB = 1
    if p0 > p1 and p0 > p2:
        axisA = 1
        axisB = 2
    elif p1 > p0 and p1 > p2:
        axisA = 0
        axisB = 2
    l1_parameter = \
        (l2[1][axisA] * l2[0][axisB] - l2[1][axisA] * l1[0][axisB] + l2[1][axisB] * l1[0][axisA] - l2[1][axisB] * l2[0][axisA]) \
            / \
        (l2[1][axisA] * l1[1][axisB] - l2[1][axisB] * l1[1][axisA])
    # plugging back into the l1 parametric line equation
    intersection = l1[0] + l1[1].multiply(l1_parameter)
    return intersection


class Cope(object):
    def __init__(self, centerline, tube_diameter):
        self.centerline = centerline
        self.tube_diameter = tube_diameter

    def reference_vector(self):
        raise(NotImplementedError)

    def reference_angle(self, first_cope):
        first_cope.get_centerline_facing_away()
        self.reference_vector()

        small_angle = first_cope.reference_vector().getAngle(self.reference_vector())
        if first_cope.get_centerline_facing_away().dot(first_cope.reference_vector().cross(self.reference_vector())) > 0:
            return small_angle
        else:
            return 0 - small_angle

    def reference_angle_along_circumference(self, first_cope):
        reference_angle = self.reference_angle(first_cope)
        circumference = self.tube_diameter * math.pi
        length_along_circumference = circumference * reference_angle / (2 * math.pi)
        return length_along_circumference


class FlatCope(Cope):
    def __init__(self, centerline, tube_diameter, cut_face_normal):
        """
        Parameters:
            centerline (Vec): normalized vector representing the centerline
                of the tubing.
            cut_face_normal (Vec): normal vector of the cut face.
        """
        super(FlatCope, self).__init__(centerline, tube_diameter)
        self.cut_face_normal = cut_face_normal

    def get_centerline_facing_away(self):
        if self.centerline.dot(self.cut_face_normal) < 0:
            return self.centerline.negative()
        else:
            return self.centerline

    def reference_vector(self):
        centerline_facing_away = self.get_centerline_facing_away()
        return centerline_facing_away.cross(self.cut_face_normal)

    def _bandsaw_angle(self):
        """
        Get a cut angle which would be indicated on a horizontal metal bandsaw.
        """
        return self.get_centerline_facing_away().getAngle(self.cut_face_normal)

    def set_references(self, prefix, reference_zero_cope):
        setref('{}/tool'.format(prefix),            "bandsaw")
        setref('{}/reference_angle'.format(prefix), self.reference_angle(reference_zero_cope), 'rad')
        setref('{}/reference_angle_along_circumference'.format(prefix), self.reference_angle_along_circumference(reference_zero_cope), 'mm')
        setref('{}/bandsaw_angle'.format(prefix),   self._bandsaw_angle(),                     'rad')


class CylindricalCope(Cope):
    def __init__(self, centerline, tube_diameter, cope_diameter, saw_direction):
        """
        Parameters:
            centerline (Vec): normalized vector representing the centerline
                of the tubing.
            saw_direction (Vec): axis of saw rotation, pointing in direction
                of cutting motion.
        """
        super(CylindricalCope, self).__init__(centerline, tube_diameter)
        self.cope_diameter = cope_diameter
        self.saw_direction = saw_direction

    def get_centerline_facing_away(self):
        if self.centerline.dot(self.saw_direction.negative()) < 0:
            return self.centerline.negative()
        else:
            return self.centerline

    def reference_vector(self):
        centerline_facing_away = self.get_centerline_facing_away()
        return centerline_facing_away.cross(self.saw_direction.negative()).cross(centerline_facing_away)

    def _notcher_angle(self):
        """
        Get a cut angle which would be indicated on a tubing notcher jig.
        """
        return self.saw_direction.getAngle(self.get_centerline_facing_away()) - (math.pi/2)

    def set_references(self, prefix, reference_zero_cope):
        setref('{}/tool'.format(prefix),            "holesaw")
        setref('{}/reference_angle'.format(prefix), self.reference_angle(reference_zero_cope), 'rad')
        setref('{}/reference_angle_along_circumference'.format(prefix), self.reference_angle_along_circumference(reference_zero_cope), 'mm')
        setref('{}/notcher_angle'.format(prefix),   self._notcher_angle(),                     'rad')
        setref('{}/cope_diameter'.format(prefix),   self.cope_diameter,                        'mm')


class CopedTubing(object):
    def __init__(self, name, part_object, shell_face_num=0, cope_faces=[]):
        self.name = name
        self.part_object = part_object
        self.shell_face_num = shell_face_num
        self.copes = []
        self.add_copes_from_faces(cope_faces)

    @property
    def center_of_mass(self):
        return self.part_object.Shape.Faces[self.shell_face_num].CenterOfMass

    @property
    def centerline(self):
        return self.part_object.Shape.Faces[self.shell_face_num].Surface.Axis

    @property
    def diameter(self):
        return 2 * self.part_object.Shape.Faces[self.shell_face_num].Surface.Radius

    def add_cope(self, cope, is_reference_zero=False):
        if is_reference_zero:
            self.copes.insert(0, cope)
        else:
            self.copes.append(cope)

    def add_copes_from_faces(self, face_objects):
        for face in face_objects:
            if isinstance(face.Surface, Part.Plane):
                self.add_flat_cope_from_face(face)
            elif isinstance(face.Surface, Part.Cylinder):
                self.add_cylindrical_cope_from_face(face)

    def add_flat_cope(self, cut_face_normal, is_reference_zero=False):
        new_cope = FlatCope(self.centerline, self.diameter, cut_face_normal)
        self.add_cope(new_cope, is_reference_zero)

    def add_flat_cope_from_face(self, face_object, is_reference_zero=False):
        self.add_flat_cope(face_object.Surface.Axis, is_reference_zero)

    def add_cylindrical_cope(self, cope_diameter, saw_direction, is_reference_zero=False):
        new_cope = CylindricalCope(self.centerline, self.diameter, cope_diameter, saw_direction)
        self.add_cope(new_cope, is_reference_zero)

    def add_cylindrical_cope_from_face(self, face_object, is_reference_zero=False):
        saw_axis = face_object.Surface.Axis
        cope_center = line_line_intersection(
            (face_object.Surface.Center, face_object.Surface.Axis),
            (self.center_of_mass, self.centerline)
        )
        towards_center = self.center_of_mass.sub(cope_center)
        if saw_axis.dot(towards_center) >= 0:
            saw_direction = saw_axis
        else:
            saw_direction = saw_axis.negative()
        self.add_cylindrical_cope(
            2 * face_object.Surface.Radius,
            saw_direction,
            is_reference_zero
        )

    def set_references(self):
        cope_idx = 0
        for cope in self.copes:
            cope_name = '{}/cope_{}'.format(self.name, cope_idx)
            cope.set_references(cope_name, self.copes[0])
            cope_idx += 1


###
# Calculating the copes for the cargo_front_tube_r
###
tube_part = App.ActiveDocument.getObjectsByLabel('cargo_front_tube_r')[0].Tip
tube = CopedTubing(
    'cargo_front_tube_r',
    tube_part,
    cope_faces=[
        # front tube / side tube joint
        tube_part.Shape.Faces[1],
        # joint between two front tubes
        tube_part.Shape.Faces[5],
        # slot for front head tube
        tube_part.Shape.Faces[6],
    ],
)
tube.set_references()

###
# Calculating the copes for the lower_down_tube
###
tube_part = App.ActiveDocument.getObjectsByLabel('lower_down_tube')[0].Tip
tube = CopedTubing(
    'lower_down_tube',
    tube_part,
    cope_faces=[
        # cope to cargo_rear_tube
        tube_part.Shape.Faces[6],
        # cope to rear_head_tube
        tube_part.Shape.Faces[5],
    ],
)
tube.set_references()

ref.recompute()

# vim: ft=python
